@author: Constantino Tsarouhas
@copyright: Lift Standard Library © 2017 The Imaginary Lift Committee

@available(from: Lift 1.0)
protocol Functor {
	
	@abstract: A value that takes an argument and produces a result; a mapping from values of one type to values of another type.
	@details {
		
		A functor is in essence a generalised pure function. They express, in most general terms, the mapping of values of type `Arguments` to values of type `Result` — without associating a concrete implementation detail. It's recommended to take a functor value instead of a function value whenever a pure function is expected.
		
		A functor can be failable. Failable functors may fail to produce a result value, and instead produce an error. The general guideline is to throw an error when a condition has occurred that prevents a value from being produced but where the functor's preconditions or invariants are still met. Division by zero is forbidden by a precondition and should therefore not produce an error; instead the division operation should raise a precondition failure (which immediately terminates the current agent). However, parsing an integer from a string should fail with an error because parsing also involves detecting strings not conforming to the grammar, which is a valid use case of parsing.
		
		A unfailable functor type can be written as `Functor<from: Argument, to: Result>` but also `Argument -> Result`. The arrow, when the type is read left-to-right, indicates the *processing* or *mapping* of a value of the left type to a value of the right type. A failable functor type can be written as `Functor<from: Argument, to: Result, throws: true>` but also `Argument throws -> Result`. The `throws` just before the arrow indicates that an error can occur before a value is produced. The `->` (and `throws ->`) type operator is right-associative type: `A -> B -> C` is the same as `A -> (B -> C)` and expresses a functor whose result is a functor `B -> C`.
		
		A functor can be applied to an argument by wrapping the argument in parentheses and juxtaposing it with the functor. This expression resolves to a result value. That is, given a functor `f : Argument -> Result` and an argument `a : Argument`, `f(a)` evaluates to a value of type `Result`. If the functor is failable, the expression or any superexpression must be prepended with the keyword `try`, e.g. `let result = try f(a)`.
		
		Every type that has a well-defined, unique “mapping” semantic (like functions) can conform to this protocol by adopting this protocol.
		
	}
	
	implicit init<Subfunctor ~ Self>(_ subfunctor: Subfunctor) where Self.Argument <: Subfunctor.Argument, Subfunctor.Result <: Self.Result, Self.failable --> Subfunctor.failable {
		@abstract: Implicitly converts a functor of type `Subfunctor` to a value of type `Self`.
		@details {
			
			Functors are contravariant on the argument type and covariant on the result type. As an example, consider two related types `Animal <: Cat` and a type `Name`.
			* Wherever a functor `Cat -> Name` is requested, a functor `Animal -> Name` can be provided.
			* Wherever a functor `Name -> Animal` is requested, a functor `Name -> Cat` can be provided.
			
			In addition, wherever a failable functor `A throws -> B` is requested, a functor `A -> B` can be given.
			
			This initialiser preserves the second-order type. For example, a method can't become a function or vice versa.
			
		}
	}
	
	type let Argument: Any.Type {
		@abstract: The type of the values the functor accepts, also known as the functor's domain.
	}
	
	type let Result: Any.Type {
		@abstract: The type of the values the functor produces, also known as the functor's image.
	}
	
	type let failable: Bool {
		@abstract: Whether the functor may fail.
	}
	
	func map(_ argument: Argument) throws[if: failable] -> Result {
		@abstract: Maps an argument to a result.
	}
	
}

extension Functor {
	derived existential type init(from Argument: Any.Type, to Result: Any.Type, throws failable: Bool = false)
}

operator class Applicative {
	strongerThan: Multiplicative
	associates: right
}

infix operator -> : Applicative
infix operator throws -> : Applicative

derived infix type operator func -> (Argument: Any.Type, Result: Any.Type) -> Functor<from: Argument, to: Result>
derived infix type operator func throws -> (Argument: Any.Type, Result: Any.Type) -> Functor<from: Argument, to: Result, throws: true>