@author: Constantino Tsarouhas
@copyright: Lift Standard Library © 2017 Lift Language Project

@available(from: Lift 1.0)
struct Method {
	
	@abstract: A function defined on a type.
	@details {
		
		A method is a function `method` with arguments `arguments` that is called on a value `subject` like this: `subject.method(arguments)`. Methods do not provide any expressive power beyond that of ordinary functions, but they improve the legibility of code by moving the subject of a function to a privileged location; for example, `let sortedList = list.sorted()` instead of `let sortedList = sort(list)`.
		
		A method is defined with a method definition within a type definition. For example,
		
			struct List {
				func sorted() -> List {
					…
				}
			}
		
		The subject value is accessible in the method through the contextual symbol `self`.
		
		A method can be mutating or nonmutating. A nonmutating method is written as above; the value `self` is constant.
		
		A mutating method is declared with the `mutating` modifier; the value `self` is variable. Any changes to `self` are reassigned to the subject value in the calling context. Therefore, the subject of a mutating method must be variable in the calling context.
		
			var name = "John Appleseed"
			name.replacingOccurrences(of: " ", with: "\t")
			// name == "John	Appleseed"
		
	}
	
	derived type init(on Subject: Any.Type, from MethodArgument: Any.Type, to MethodResult: Any.Type, mutating: Bool = false, throws failable: Bool = false)
	
	type let Subject: Any.Type {
		@abstract: The type of values on which the method is defined.
	}
	
	type let MethodArguments: Array<of: FunctorArgument.Type> {
		@abstract: The type of arguments taken by methods.
	}
	
	type let Arguments = mutating ? (inout Subject ++ MethodArguments) : (Subject ++ MethodArguments)
	
	type let Result: Any.Type
	
	type let mutating: Bool {
		@abstract: Whether the method can mutate the subject value in-place.
	}
	
	type let failable: Bool {
		@abstract: Whether the bound method may fail.
	}
	
	native let implementation: Implementation {
		@abstract: The implementation of the method.
		@details: The compiler (…).
	}
	
}

@available(from: Lift 1.0)
extension Method : Functor where !mutating {
	
	@abstract: Every immutable method is a functor that takes the subject value as first argument.
	@details {
		
		Nonmutating methods are functors that take a subject as first argument, followed by the method arguments, and produce the method's result. Or, more formally stated,
		* every nonmutating, unfailable method `Method<on: Subject, from: Arguments, to: Result>` is a functor `(Subject ++ Arguments) -> Result`, and
		* every nonmutating, failable method `Method<on: Subject, from: Argument, to: Result, throws: true>` is a functor `(Subject ++ Arguments) throws -> Result`.
		
		Mutating methods require a variable context and thus are not functors.
		
	}
	
	type let Arguments = Subject ++ MethodArguments
	
	derived implicit init<Submethod : Method>(_ submethod: Submethod) where Self.Argument <: Submethod.Argument, Submethod.Result <: Self.Result, Self.failable --> Submethod.failable {
	
}